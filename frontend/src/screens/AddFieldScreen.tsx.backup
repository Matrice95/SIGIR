/**
 * √âcran Ajouter Parcelle
 * Formulaire complet pour cr√©er une nouvelle parcelle de riz
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TextInput,
  KeyboardAvoidingView,
  Platform,
  Alert,
  Pressable,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useNavigation } from '@react-navigation/native';
import DateTimePicker from '@react-native-community/datetimepicker';

// Components
import Button from '@/components/Button';
import Card from '@/components/Card';

// Store & Constants
import { useAppDispatch } from '@/store/hooks';
import { addField, setActiveField } from '@/store/slices/fieldsSlice';
import { fieldService } from '@/services/fieldService';
import { COLORS, SPACING, TYPOGRAPHY } from '@/constants/theme';
import { RICE_VARIETIES, SOIL_TYPES } from '@/constants/config';
import {
  getAvailableZones,
  getSowingWindowsForZone,
  getZoneInfo,
  isDateInSowingWindow,
  formatSowingWindow,
  type SowingWindow,
} from '@/constants/sowingCalendar';

export default function AddFieldScreen() {
  const navigation = useNavigation();
  const dispatch = useAppDispatch();

  // √âtat du formulaire
  const [name, setName] = useState('');
  const [area, setArea] = useState('');
  const [variety, setVariety] = useState('');
  const [soilType, setSoilType] = useState('');
  const [zone, setZone] = useState('');
  const [locality, setLocality] = useState('');
  const [sowingWindow, setSowingWindow] = useState<SowingWindow | null>(null);
  const [sowingDate, setSowingDate] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [latitude, setLatitude] = useState('');
  const [longitude, setLongitude] = useState('');
  const [notes, setNotes] = useState('');
  
  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});

  // Zones et fen√™tres disponibles
  const availableZones = getAvailableZones();
  const sowingWindows = zone ? getSowingWindowsForZone(zone) : [];
  const selectedZoneInfo = zone ? getZoneInfo(zone) : null;

  // Validation du formulaire
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!name.trim()) {
      newErrors.name = 'Le nom de la parcelle est requis';
    }

    if (!area || parseFloat(area) <= 0) {
      newErrors.area = 'La superficie doit √™tre sup√©rieure √† 0';
    }

    if (!variety) {
      newErrors.variety = 'Veuillez s√©lectionner une vari√©t√©';
    }

    if (!zone) {
      newErrors.zone = 'Veuillez s√©lectionner une zone g√©ographique';
    }

    if (!locality) {
      newErrors.locality = 'Veuillez s√©lectionner une localit√©';
    }

    if (!sowingWindow) {
      newErrors.sowingWindow = 'Veuillez s√©lectionner une fen√™tre de semis optimale';
    }

    if (!soilType) {
      newErrors.soilType = 'Veuillez s√©lectionner un type de sol';
    }

    if (latitude && (parseFloat(latitude) < -90 || parseFloat(latitude) > 90)) {
      newErrors.latitude = 'Latitude invalide (-90 √† 90)';
    }

    if (longitude && (parseFloat(longitude) < -180 || parseFloat(longitude) > 180)) {
      newErrors.longitude = 'Longitude invalide (-180 √† 180)';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // G√©rer la soumission
  const handleSubmit = async () => {
    if (!validateForm()) {
      Alert.alert('Erreur', 'Veuillez corriger les erreurs dans le formulaire');
      return;
    }

    setLoading(true);

    try {
      // Pr√©parer les donn√©es pour le backend
      const fieldData = {
        name: name.trim(),
        area: parseFloat(area),
        crop_type: 'rice', // Type de culture fixe pour le riz
        variety,
        planting_date: sowingDate.toISOString(),
        latitude: latitude ? parseFloat(latitude) : undefined,
        longitude: longitude ? parseFloat(longitude) : undefined,
        soil_type: soilType,
      };

      console.log('üì§ Envoi de la parcelle au backend:', fieldData);

      // Cr√©er la parcelle via l'API
      const createdField = await fieldService.createField(fieldData);
      
      console.log('‚úÖ Parcelle cr√©√©e avec succ√®s:', createdField);

      // Ajouter la parcelle au store Redux
      const formattedField = {
        id: createdField.id,
        name: createdField.name,
        area: createdField.area,
        variety: createdField.variety || 'Non sp√©cifi√©',
        sowingDate: createdField.planting_date || sowingDate.toISOString(),
        currentStage: 'germination',
        healthStatus: createdField.status || 'good',
        location: createdField.latitude && createdField.longitude 
          ? { latitude: createdField.latitude, longitude: createdField.longitude }
          : undefined,
        soilType: createdField.soil_type,
        notes: undefined,
      };

      dispatch(addField(formattedField));
      dispatch(setActiveField(formattedField.id));

      Alert.alert(
        'Succ√®s',
        'La parcelle a √©t√© cr√©√©e avec succ√®s !',
        [
          {
            text: 'OK',
            onPress: () => navigation.goBack(),
          },
        ]
      );
    } catch (error: any) {
      console.error('‚ùå Erreur cr√©ation parcelle:', error);
      Alert.alert('Erreur', error.message || 'Impossible de cr√©er la parcelle');
    } finally {
      setLoading(false);
    }
  };

  const handleDateChange = (event: any, selectedDate?: Date) => {
    setShowDatePicker(false);
    if (selectedDate && sowingWindow) {
      // V√©rifier que la date est dans la fen√™tre de semis
      if (isDateInSowingWindow(selectedDate, sowingWindow)) {
        setSowingDate(selectedDate);
        setErrors({ ...errors, sowingDate: '' });
      } else {
        Alert.alert(
          'Date invalide',
          `La date doit √™tre dans la fen√™tre de semis optimale:\n${formatSowingWindow(sowingWindow, selectedDate.getFullYear())}\n\nProbabilit√© de succ√®s: ${sowingWindow.successProbability}%`,
          [{ text: 'OK' }]
        );
      }
    } else if (selectedDate) {
      setSowingDate(selectedDate);
    }
  };

  const formatDate = (date: Date) => {
    return date.toLocaleDateString('fr-FR', {
      day: '2-digit',
      month: 'long',
      year: 'numeric',
    });
  };

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      style={styles.container}
    >
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        keyboardShouldPersistTaps="handled"
      >
        {/* En-t√™te */}
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Nouvelle parcelle</Text>
          <Text style={styles.headerSubtitle}>
            Renseignez les informations de votre parcelle de riz
          </Text>
        </View>

        {/* Informations de base */}
        <Card style={styles.section}>
          <Text style={styles.sectionTitle}>üìã Informations de base</Text>

          {/* Nom */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              Nom de la parcelle <Text style={styles.required}>*</Text>
            </Text>
            <TextInput
              style={[styles.input, errors.name && styles.inputError]}
              placeholder="Ex: Parcelle Nord"
              value={name}
              onChangeText={(text) => {
                setName(text);
                setErrors({ ...errors, name: '' });
              }}
              maxLength={50}
            />
            {errors.name && <Text style={styles.errorText}>{errors.name}</Text>}
          </View>

          {/* Superficie */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              Superficie (hectares) <Text style={styles.required}>*</Text>
            </Text>
            <TextInput
              style={[styles.input, errors.area && styles.inputError]}
              placeholder="Ex: 2.5"
              value={area}
              onChangeText={(text) => {
                // Accepter seulement nombres et point d√©cimal
                const cleaned = text.replace(/[^0-9.]/g, '');
                setArea(cleaned);
                setErrors({ ...errors, area: '' });
              }}
              keyboardType="decimal-pad"
              maxLength={10}
            />
            {errors.area && <Text style={styles.errorText}>{errors.area}</Text>}
          </View>
        </Card>

        {/* Culture */}
        <Card style={styles.section}>
          <Text style={styles.sectionTitle}>üåæ Culture</Text>

          {/* Vari√©t√© */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              Vari√©t√© de riz <Text style={styles.required}>*</Text>
            </Text>
            <View style={styles.pickerContainer}>
              {RICE_VARIETIES.map((v) => (
                <Pressable
                  key={v.id}
                  style={[
                    styles.pickerOption,
                    variety === v.name && styles.pickerOptionSelected,
                  ]}
                  onPress={() => {
                    setVariety(v.name);
                    setErrors({ ...errors, variety: '' });
                  }}
                >
                  <Text
                    style={[
                      styles.pickerOptionText,
                      variety === v.name && styles.pickerOptionTextSelected,
                    ]}
                  >
                    {v.name}
                  </Text>
                  <Text style={styles.pickerOptionDetail}>
                    {v.cycle} jours ‚Ä¢ {v.type}
                  </Text>
                </Pressable>
              ))}
            </View>
            {errors.variety && <Text style={styles.errorText}>{errors.variety}</Text>}
          </View>

        </Card>

        {/* Zone g√©ographique et localit√© */}
        <Card style={styles.section}>
          <Text style={styles.sectionTitle}>üìç Zone g√©ographique</Text>
          
          {/* Zone */}
          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              Zone <Text style={styles.required}>*</Text>
            </Text>
            <View style={styles.pickerContainer}>
              {availableZones.map((z) => (
                <Pressable
                  key={z.id}
                  style={[
                    styles.pickerOption,
                    zone === z.id && styles.pickerOptionSelected,
                  ]}
                  onPress={() => {
                    setZone(z.id);
                    setLocality('');
                    setSowingWindow(null);
                    setErrors({ ...errors, zone: '', locality: '', sowingWindow: '' });
                  }}
                >
                  <Text
                    style={[
                      styles.pickerOptionText,
                      zone === z.id && styles.pickerOptionTextSelected,
                    ]}
                  >
                    {z.name}
                  </Text>
                </Pressable>
              ))}
            </View>
            {errors.zone && <Text style={styles.errorText}>{errors.zone}</Text>}
          </View>

          {/* Localit√© */}
          {zone && selectedZoneInfo && (
            <View style={styles.inputGroup}>
              <Text style={styles.label}>
                Localit√© <Text style={styles.required}>*</Text>
              </Text>
              <View style={styles.pickerContainer}>
                {selectedZoneInfo.localities.map((loc) => (
                  <Pressable
                    key={loc}
                    style={[
                      styles.pickerOption,
                      locality === loc && styles.pickerOptionSelected,
                    ]}
                    onPress={() => {
                      setLocality(loc);
                      setErrors({ ...errors, locality: '' });
                    }}
                  >
                    <Text
                      style={[
                        styles.pickerOptionText,
                        locality === loc && styles.pickerOptionTextSelected,
                      ]}
                    >
                      {loc}
                    </Text>
                  </Pressable>
                ))}
              </View>
              {errors.locality && <Text style={styles.errorText}>{errors.locality}</Text>}
            </View>
          )}

          {/* Info zone */}
          {selectedZoneInfo && (
            <View style={styles.zoneInfoBox}>
              <Ionicons name="information-circle" size={20} color="#2196F3" />
              <View style={styles.zoneInfoContent}>
                <Text style={styles.zoneInfoText}>
                  {selectedZoneInfo.description}
                </Text>
                <Text style={styles.zoneInfoDetail}>
                  üåæ Cycles/an: {selectedZoneInfo.cyclesPerYear} ‚Ä¢ R√©gime: {selectedZoneInfo.regime}
                </Text>
              </View>
            </View>
          )}
        </Card>

        {/* Fen√™tre de semis optimale */}
        {zone && variety && (
          <Card style={styles.section}>
            <Text style={styles.sectionTitle}>üìÖ Fen√™tre de semis optimale</Text>
            
            <View style={styles.inputGroup}>
              <Text style={styles.label}>
                P√©riode recommand√©e <Text style={styles.required}>*</Text>
              </Text>
              <Text style={styles.helperText}>
                ‚ö†Ô∏è Vous devez choisir une fen√™tre de semis optimale bas√©e sur des recherches scientifiques (1980-2017)
              </Text>
              
              <View style={styles.pickerContainer}>
                {sowingWindows
                  .filter(w => w.varieties.includes(variety))
                  .map((window) => (
                    <Pressable
                      key={window.id}
                      style={[
                        styles.sowingWindowCard,
                        sowingWindow?.id === window.id && styles.sowingWindowCardSelected,
                      ]}
                      onPress={() => {
                        setSowingWindow(window);
                        // D√©finir une date par d√©faut dans la fen√™tre
                        const [startMonth, startDay] = window.startDate.split('-').map(Number);
                        const defaultDate = new Date(new Date().getFullYear(), startMonth - 1, startDay);
                        setSowingDate(defaultDate);
                        setErrors({ ...errors, sowingWindow: '' });
                      }}
                    >
                      <View style={styles.sowingWindowHeader}>
                        <Text style={[
                          styles.sowingWindowTitle,
                          sowingWindow?.id === window.id && styles.sowingWindowTitleSelected,
                        ]}>
                          {window.label}
                        </Text>
                        <View style={[
                          styles.successBadge,
                          { backgroundColor: window.successProbability >= 80 ? '#dcfce7' : '#fef3c7' }
                        ]}>
                          <Text style={[
                            styles.successBadgeText,
                            { color: window.successProbability >= 80 ? '#16a34a' : '#ca8a04' }
                          ]}>
                            {window.successProbability}% succ√®s
                          </Text>
                        </View>
                      </View>

                      <Text style={styles.sowingWindowCycle}>{window.cycleLabel}</Text>
                      <Text style={styles.sowingWindowDate}>
                        üìÖ {formatSowingWindow(window, new Date().getFullYear())}
                      </Text>

                      {window.warning && (
                        <View style={styles.warningBox}>
                          <Ionicons name="warning" size={16} color="#f97316" />
                          <Text style={styles.warningText}>{window.warning}</Text>
                        </View>
                      )}

                      <View style={styles.recommendationsList}>
                        {window.recommendations.slice(0, 2).map((rec, idx) => (
                          <Text key={idx} style={styles.recommendationItem}>
                            ‚Ä¢ {rec}
                          </Text>
                        ))}
                      </View>
                    </Pressable>
                  ))}
              </View>
              {errors.sowingWindow && <Text style={styles.errorText}>{errors.sowingWindow}</Text>}
            </View>

            {/* Date de semis pr√©cise */}
            {sowingWindow && (
              <View style={styles.inputGroup}>
                <Text style={styles.label}>
                  Date de semis pr√©cise <Text style={styles.required}>*</Text>
                </Text>
                <Text style={styles.helperText}>
                  La date doit √™tre dans la fen√™tre s√©lectionn√©e
                </Text>
                <Pressable
                  style={styles.dateButton}
                  onPress={() => setShowDatePicker(true)}
                >
                  <Ionicons name="calendar" size={20} color={COLORS.primary} />
                  <Text style={styles.dateButtonText}>{formatDate(sowingDate)}</Text>
                </Pressable>
                {showDatePicker && (
                  <DateTimePicker
                    value={sowingDate}
                    mode="date"
                    display="default"
                    onChange={handleDateChange}
                  />
                )}
              </View>
            )}
          </Card>
        )}

        {/* Message si vari√©t√© ou zone manquante */}
        {(!zone || !variety) && (
          <Card style={styles.section}>
            <View style={styles.emptyStateBox}>
              <Ionicons name="calendar-outline" size={40} color={COLORS.textSecondary} />
              <Text style={styles.emptyStateText}>
                S√©lectionnez d'abord une zone g√©ographique et une vari√©t√© de riz
              </Text>
            </View>
          </Card>
        )}

        {/* Sol */}
        <Card style={styles.section}>
          <Text style={styles.sectionTitle}>üèûÔ∏è Type de sol</Text>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>
              Type de sol <Text style={styles.required}>*</Text>
            </Text>
            <View style={styles.pickerContainer}>
              {SOIL_TYPES.map((soil) => (
                <Pressable
                  key={soil.id}
                  style={[
                    styles.pickerOption,
                    soilType === soil.name && styles.pickerOptionSelected,
                  ]}
                  onPress={() => {
                    setSoilType(soil.name);
                    setErrors({ ...errors, soilType: '' });
                  }}
                >
                  <Text
                    style={[
                      styles.pickerOptionText,
                      soilType === soil.name && styles.pickerOptionTextSelected,
                    ]}
                  >
                    {soil.name}
                  </Text>
                  <Text style={styles.pickerOptionDetail}>{soil.description}</Text>
                </Pressable>
              ))}
            </View>
            {errors.soilType && <Text style={styles.errorText}>{errors.soilType}</Text>}
          </View>
        </Card>

        {/* Localisation (optionnel) */}
        <Card style={styles.section}>
          <Text style={styles.sectionTitle}>üìç Localisation (optionnel)</Text>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Latitude</Text>
            <TextInput
              style={[styles.input, errors.latitude && styles.inputError]}
              placeholder="Ex: 5.3600"
              value={latitude}
              onChangeText={(text) => {
                const cleaned = text.replace(/[^0-9.-]/g, '');
                setLatitude(cleaned);
                setErrors({ ...errors, latitude: '' });
              }}
              keyboardType="decimal-pad"
            />
            {errors.latitude && <Text style={styles.errorText}>{errors.latitude}</Text>}
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>Longitude</Text>
            <TextInput
              style={[styles.input, errors.longitude && styles.inputError]}
              placeholder="Ex: -4.0083"
              value={longitude}
              onChangeText={(text) => {
                const cleaned = text.replace(/[^0-9.-]/g, '');
                setLongitude(cleaned);
                setErrors({ ...errors, longitude: '' });
              }}
              keyboardType="decimal-pad"
            />
            {errors.longitude && <Text style={styles.errorText}>{errors.longitude}</Text>}
          </View>

          <Button
            title="Utiliser ma position"
            onPress={() => {
              // TODO: Impl√©menter g√©olocalisation
              Alert.alert('Info', 'Fonctionnalit√© √† venir');
            }}
            variant="outline"
            icon="location"
            size="small"
          />
        </Card>

        {/* Notes (optionnel) */}
        <Card style={styles.section}>
          <Text style={styles.sectionTitle}>üìù Notes (optionnel)</Text>

          <TextInput
            style={styles.textArea}
            placeholder="Ajoutez des notes sur cette parcelle..."
            value={notes}
            onChangeText={setNotes}
            multiline
            numberOfLines={4}
            textAlignVertical="top"
            maxLength={500}
          />
          <Text style={styles.charCount}>{notes.length}/500</Text>
        </Card>

        {/* Boutons d'action */}
        <View style={styles.actions}>
          <Button
            title="Annuler"
            onPress={() => navigation.goBack()}
            variant="outline"
            fullWidth
            disabled={loading}
          />
          <Button
            title="Cr√©er la parcelle"
            onPress={handleSubmit}
            variant="primary"
            fullWidth
            loading={loading}
            icon="checkmark-circle"
            style={styles.submitButton}
          />
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  scrollView: {
    flex: 1,
  },
  content: {
    padding: SPACING.base,
    paddingBottom: SPACING.xxxl,
  },
  header: {
    marginBottom: SPACING.lg,
  },
  headerTitle: {
    fontSize: TYPOGRAPHY.fontSize.xxl,
    fontWeight: TYPOGRAPHY.fontWeight.bold,
    color: COLORS.text,
    marginBottom: SPACING.xs,
  },
  headerSubtitle: {
    fontSize: TYPOGRAPHY.fontSize.base,
    color: COLORS.textSecondary,
  },
  section: {
    marginBottom: SPACING.base,
  },
  sectionTitle: {
    fontSize: TYPOGRAPHY.fontSize.lg,
    fontWeight: TYPOGRAPHY.fontWeight.bold,
    color: COLORS.text,
    marginBottom: SPACING.md,
  },
  inputGroup: {
    marginBottom: SPACING.md,
  },
  label: {
    fontSize: TYPOGRAPHY.fontSize.base,
    fontWeight: TYPOGRAPHY.fontWeight.semibold,
    color: COLORS.text,
    marginBottom: SPACING.xs,
  },
  required: {
    color: COLORS.error,
  },
  input: {
    height: 48,
    borderWidth: 1.5,
    borderColor: COLORS.border,
    borderRadius: 8,
    paddingHorizontal: SPACING.base,
    fontSize: TYPOGRAPHY.fontSize.base,
    color: COLORS.text,
    backgroundColor: COLORS.surface,
  },
  inputError: {
    borderColor: COLORS.error,
  },
  errorText: {
    fontSize: TYPOGRAPHY.fontSize.sm,
    color: COLORS.error,
    marginTop: SPACING.xs,
  },
  textArea: {
    height: 100,
    borderWidth: 1.5,
    borderColor: COLORS.border,
    borderRadius: 8,
    paddingHorizontal: SPACING.base,
    paddingVertical: SPACING.sm,
    fontSize: TYPOGRAPHY.fontSize.base,
    color: COLORS.text,
    backgroundColor: COLORS.surface,
  },
  charCount: {
    fontSize: TYPOGRAPHY.fontSize.sm,
    color: COLORS.textSecondary,
    textAlign: 'right',
    marginTop: SPACING.xs,
  },
  pickerContainer: {
    gap: SPACING.sm,
  },
  pickerOption: {
    padding: SPACING.md,
    borderWidth: 1.5,
    borderColor: COLORS.border,
    borderRadius: 8,
    backgroundColor: COLORS.surface,
  },
  pickerOptionSelected: {
    borderColor: COLORS.primary,
    backgroundColor: `${COLORS.primary}10`,
  },
  pickerOptionText: {
    fontSize: TYPOGRAPHY.fontSize.base,
    fontWeight: TYPOGRAPHY.fontWeight.semibold,
    color: COLORS.text,
    marginBottom: SPACING.xs,
  },
  pickerOptionTextSelected: {
    color: COLORS.primary,
  },
  pickerOptionDetail: {
    fontSize: TYPOGRAPHY.fontSize.sm,
    color: COLORS.textSecondary,
  },
  dateButton: {
    flexDirection: 'row',
    alignItems: 'center',
    height: 48,
    borderWidth: 1.5,
    borderColor: COLORS.border,
    borderRadius: 8,
    paddingHorizontal: SPACING.base,
    backgroundColor: COLORS.surface,
  },
  dateButtonText: {
    fontSize: TYPOGRAPHY.fontSize.base,
    color: COLORS.text,
    marginLeft: SPACING.sm,
    flex: 1,
  },
  zoneInfoBox: {
    flexDirection: 'row',
    backgroundColor: '#e3f2fd',
    padding: SPACING.md,
    borderRadius: 8,
    marginTop: SPACING.sm,
  },
  zoneInfoContent: {
    flex: 1,
    marginLeft: SPACING.sm,
  },
  zoneInfoText: {
    fontSize: TYPOGRAPHY.fontSize.sm,
    color: '#1565c0',
    marginBottom: SPACING.xs,
  },
  zoneInfoDetail: {
    fontSize: TYPOGRAPHY.fontSize.sm,
    color: '#1976d2',
    fontWeight: TYPOGRAPHY.fontWeight.medium,
  },
  helperText: {
    fontSize: TYPOGRAPHY.fontSize.sm,
    color: COLORS.textSecondary,
    marginBottom: SPACING.sm,
    fontStyle: 'italic',
  },
  sowingWindowCard: {
    padding: SPACING.md,
    borderWidth: 2,
    borderColor: COLORS.border,
    borderRadius: 12,
    backgroundColor: COLORS.surface,
    marginBottom: SPACING.sm,
  },
  sowingWindowCardSelected: {
    borderColor: COLORS.primary,
    backgroundColor: `${COLORS.primary}08`,
  },
  sowingWindowHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: SPACING.xs,
  },
  sowingWindowTitle: {
    fontSize: TYPOGRAPHY.fontSize.base,
    fontWeight: TYPOGRAPHY.fontWeight.bold,
    color: COLORS.text,
    flex: 1,
  },
  sowingWindowTitleSelected: {
    color: COLORS.primary,
  },
  successBadge: {
    paddingHorizontal: SPACING.sm,
    paddingVertical: 4,
    borderRadius: 12,
  },
  successBadgeText: {
    fontSize: TYPOGRAPHY.fontSize.xs,
    fontWeight: TYPOGRAPHY.fontWeight.bold,
  },
  sowingWindowCycle: {
    fontSize: TYPOGRAPHY.fontSize.sm,
    color: COLORS.textSecondary,
    marginBottom: SPACING.xs,
  },
  sowingWindowDate: {
    fontSize: TYPOGRAPHY.fontSize.sm,
    color: COLORS.text,
    fontWeight: TYPOGRAPHY.fontWeight.medium,
    marginBottom: SPACING.sm,
  },
  warningBox: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fff7ed',
    padding: SPACING.sm,
    borderRadius: 6,
    marginBottom: SPACING.sm,
  },
  warningText: {
    fontSize: TYPOGRAPHY.fontSize.sm,
    color: '#f97316',
    marginLeft: SPACING.xs,
    flex: 1,
  },
  recommendationsList: {
    gap: 4,
  },
  recommendationItem: {
    fontSize: TYPOGRAPHY.fontSize.sm,
    color: COLORS.textSecondary,
  },
  emptyStateBox: {
    alignItems: 'center',
    padding: SPACING.xl,
  },
  emptyStateText: {
    fontSize: TYPOGRAPHY.fontSize.base,
    color: COLORS.textSecondary,
    textAlign: 'center',
    marginTop: SPACING.sm,
  },
  actions: {
    marginTop: SPACING.lg,
    gap: SPACING.md,
  },
  submitButton: {
    marginTop: SPACING.xs,
  },
});
